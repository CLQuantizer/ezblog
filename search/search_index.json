{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ezio's blog","text":"<p>Click on top-left corner to get a list of topics and writings.</p> <p>2023, Ezio</p>"},{"location":"blog/Rust/","title":"Rust","text":"<p>26/01/2023</p>"},{"location":"blog/Rust/#i-want-to-learn-rust","title":"I want to learn Rust","text":"<p>Here is a list of things that I love about Rust:</p> <ul> <li>The potential to get paid a lot</li> </ul>"},{"location":"blog/Epistemology/EPDPistemology/","title":"EPDPistemology","text":"<p>24/02/2023</p>"},{"location":"blog/Epistemology/EPDPistemology/#an-epistemology-based-on-parallel-distributed-processing","title":"An epistemology based on parallel distributed processing","text":"<p>I seek to think in the way J\u00fcrgen Schmidhuber thinks.</p> <p>When asked about what consicousness is by Lex Fridman  Schmidhuber answered: When we have an LSTM as a predictive model of the world which minimizes pain and other undesired shit</p> <p>Compression, or model making, is a sub-process of prediction. During the training phase, the LSTM is naturally optimized in such a way that it constructs models which represent parts of the \"self\". The relationship between the LSTM and these models is consciousness.</p> <p>Epistemology primarily seeks to answer this question: what is knowledge?</p> <p>We will have to answer it in a Schmidhuberig way.</p> <p>How do we do that?</p>"},{"location":"blog/Rust_Misc/Rust_Box/","title":"Rust Box","text":"<p>29/01/2023</p> <p>I ask this question: what does Box do in Rust? <p>ChatGPT says:</p> <p>In Rust, a Box is a smart pointer that allocates memory on the heap, rather than on the stack. <p>It is used when you want to store data on the heap,  but do not know the exact size of the data at compile time,  or when you want to transfer ownership of an allocated piece of memory to a different part of your code.</p> <p>A Box is implemented as a wrapper around a raw pointer,  and it automatically handles the details of allocating and deallocating memory on the heap.  <p>When a Box is dropped, the memory it points to is automatically deallocated,  which makes it easy to avoid memory leaks. <p>Here is an example of using a Box to store a string on the heap: <p><pre><code>let b = Box::new(String::from(\"Hello, World!\"));\nprintln!(\"{}\", b);\n</code></pre> Another question here: if I did not Box it, would the String not be stored on the heap?</p> <p>ChatGPT does not actually know this.</p> <p>Box is also used when you want to store a struct on the heap  and also want to get the ownership of the data, for example: <p><pre><code>struct MyStruct {\n    data: i32,\n}\nlet my_struct = Box::new(MyStruct { data: 5 });\n</code></pre> One important thing to note is that Box can't be used  in certain contexts where the size of the type is needed at compile time,  such as in the case of arrays and certain types of collections.  For those cases, you can use Vec and VecDeque types. <p>Box is useful when you want to store complex data types on the heap,  and you want to transfer ownership of the data around your code  without worrying about the details of memory management."},{"location":"blog/Rust_Misc/Rust_Box/#common-methods-associated-with-box","title":"Common methods associated with Box <pre><code>new(x: T) -&gt; Box&lt;T&gt;: \n    This method creates a new Box&lt;T&gt; that points to a value of type T on the heap. \n    It takes one argument, which is the value to be stored in the box.\nderef(&amp;self) -&gt; &amp;T: \n    This method returns a reference to the data stored in the Box&lt;T&gt;. \n    It allows you to access the data stored in the box as if it were a regular variable.\nderef_mut(&amp;mut self) -&gt; &amp;mut T: \n    Similar to deref, but returns a mutable reference to the data stored in the box.\ndrop(&amp;mut self): \n    This method is called when a Box&lt;T&gt; goes out of scope. \n    It deallocates the memory that the box points to.\ninto_raw(b: Box&lt;T&gt;) -&gt; *mut T: \n    This method converts a Box&lt;T&gt; into a raw pointer. \n    It takes a Box&lt;T&gt; as an argument and returns a raw pointer to the data it points to.\nfrom_raw(ptr: *mut T) -&gt; Box&lt;T&gt;: \n    This method creates a Box&lt;T&gt; from a raw pointer. \n    It takes a raw pointer as an argument and returns a Box&lt;T&gt; that points to the same data.\n</code></pre>","text":""},{"location":"blog/Rust_Misc/Rust_Box/#conclusion","title":"Conclusion <p>I did not understand what is going on. I am still using the mental model for Java Box. Whatever bruv. I don't really care</p>","text":""},{"location":"blog/Rust_Misc/Rust_Option/","title":"Rust Option","text":"<p>31/01/2023</p>"},{"location":"blog/Rust_Misc/Rust_Option/#i-want-to-write-a-few-snippets-to-explore-the-enum-option-in-rust","title":"I want to write a few snippets to explore the enum \"Option\" in Rust","text":"<p>Let's go:</p>"},{"location":"blog/Rust_Misc/Rust_Option/#the-declaration","title":"The declaration:","text":"<pre><code>pub enum Option&lt;T&gt; {\n    None,\n    Some(T),\n}\n</code></pre>"},{"location":"blog/Rust_Misc/Rust_ref_deref/","title":"Rust ref deref","text":"<p>08/03/2023</p>"},{"location":"blog/Rust_Misc/Rust_ref_deref/#nothing-makes-any-sense","title":"Nothing makes any sense.","text":"<p>Here I write a few snippets and show how ridiculous everything is.</p> <pre><code>fn main() {\n    let a = String::from(\"hello\");\n    let b = &amp;a;\n    let c = *b; // Error!\n}\n</code></pre> <p>This does not work. Same happens for mutable ref.</p>"},{"location":"blog/Rust_Misc/Rust_ref_deref/#what-does-do-then","title":"What does * do then?","text":"<p>Indeed if it is not deref, what the fuck does it do? Micouy here talks about it: </p> <p>dereferencing acutally isn\u2019t the opposite of referencing in Rust</p> <p>The opposite of referencing is dropping a reference, and the deref operator is totally unrelated to the ref operator. </p> <p>In Rust the meaning of &amp; and * depend on the context.</p> <p>Given a struct <code>Thing</code>,</p> <pre><code>struct Thing {\n    field: String,\n}\n</code></pre> <pre><code>// Compiles. Straight and simple.\nfn f1(thing: &amp;Thing) -&gt; &amp;String {\n    &amp;thing.field\n}\n\n// Doesn't compile...\nfn f2(thing: &amp;Thing) -&gt; &amp;String {\n    let tmp = thing.field;\n\n    &amp;tmp\n}\n\n// Compiles?!\nfn f3(thing: &amp;Thing) -&gt; &amp;String {\n    &amp;(thing.field)\n}\n</code></pre>"},{"location":"blog/Rust_memory/Borrow_and_Reference_in_Rust/","title":"Borrow and Reference in Rust","text":"<p>26/01/2023</p>"},{"location":"blog/Rust_memory/Borrow_and_Reference_in_Rust/#borrows-and-references","title":"Borrows and References","text":"<p>First up, here are some Casses-t\u00eate chinois from rust-lang: The Rules of References</p> <ul> <li>At any given time, you can have either one mutable reference or many immutable references.</li> <li>References must always be valid.</li> </ul> <p>We'll return to these later, or not.</p>"},{"location":"blog/Rust_memory/Borrow_and_Reference_in_Rust/#i-ask-three-questions-here","title":"I ask three questions here:","text":"<ul> <li>What is mutable in a mutable reference?</li> <li>What is immutable in an immutable reference?</li> <li>What does it mean to borrow?</li> </ul>"},{"location":"blog/Rust_memory/Borrow_and_Reference_in_Rust/#borrowing-has-been-shown-here","title":"Borrowing has been shown here","text":"<p>In short, in Rust world, borrowing is the action of creating a reference.</p> <p>The real life analogy of borrowing a pen from a colleague does not seem work here. This is because in Rust, a borrowed value cannot be modified. By writing with the pen, you modify the amount of ink in it. By borrowing the Mona List, you take away \u2153 of the revenue of the Louvre according to some study of Harvard University in 1876.</p> <p>When Sam Bankman-Fried, creator of FTX, son of Jeseph Bankman from the land of freedom and prosperity the United States of America, borrowed the money from its users, did he not modify the money? Hell yeh he did, and in the wildest dactylic hexameter you can imagine.</p> <p>And, there are two types of borrowing/referencing in Rust: mut ref and immut ref  </p>"},{"location":"blog/Rust_memory/Borrow_and_Reference_in_Rust/#mutable-reference-by-example","title":"Mutable reference by example","text":"<p>Compilation failures are always the best for learning: <pre><code>fn main() {\n    let s1 = String::from(\"Kaggle\");\n    borrows(&amp;s1);\n    println!(\"{}\", s1);\n}\n\nfn borrows(prey: &amp;String){\n    prey.push_str(\" is so dead\");\n}\n</code></pre> The help message from the compiler is:     ------- help: consider changing this to be a mutable reference: <code>&amp;mut String</code></p> <p>So that is what I did to turn it into the program below. Note that s1 has to be declared mut too. Otherwise it ain't compile.</p> <pre><code>fn main() {\n    let mut s1 = String::from(\"Kaggle\");\n    borrows(&amp;mut s1);\n    println!(\"{}\", s1);\n\n}\n\nfn borrows(prey: &amp;mut String){\n    prey.push_str(\" is so dead\");\n}\n</code></pre> <p>It compiles and says Kaggle is so dead.</p> <p>Up to this point, it seems that a mutable reference is a mutable reference to a mutable variable. </p> <p>Let's table these babies shall we?</p> mut var immu var mut ref \u2714\ufe0f one and only \u2764\ufe0f \u26cc immut ref \u2714\ufe0f promiscuous \u2714\ufe0f promiscuous <p>I'm not even sure if this correct. Lol.</p>"},{"location":"blog/Rust_memory/Borrow_and_Reference_in_Rust/#answers-to-questions","title":"Answers to questions:","text":"<ul> <li>To borrow is to refer</li> <li>What is mutable in a mutable reference is the value borrowed from a poor mutable variable.</li> <li>What is immutable in a immutable reference is, well, I don't care.</li> </ul>"},{"location":"blog/Rust_memory/Ownership_in_Rust/","title":"Ownership in Rust","text":"<p>26/01/2023</p>"},{"location":"blog/Rust_memory/Ownership_in_Rust/#about-ownership-in-rust-heres-what-i-want-to-ask","title":"About ownership in Rust, here's what I want to ask:","text":"<ul> <li>What can be an owner in Rust? Thread? Scope? Function? Variable?</li> <li>Are there any differences among these ownerships?</li> </ul>"},{"location":"blog/Rust_memory/Ownership_in_Rust/#short-answers-to-our-questions","title":"Short answers to our questions","text":"<ul> <li>Owners include functions and variables. They own values (but what are values?)</li> <li>Ownership is ownership. It is memroy talk. </li> </ul>"},{"location":"blog/Rust_memory/Ownership_in_Rust/#the-problem-of-mem-alloc","title":"The problem of mem alloc","text":"<p>In most languages without a Garbage Collector, when a chunk of memory ain't used anymore, programmers should call code to explicitly free it, just as when they requested it.</p> <p>This is difficult: if we forget to free, we\u2019ll waste memory. If we do it too early, we\u2019ll have an invalid variable. If we do it twice, that\u2019s a bug too. We need to pair exactly one allocate with exactly one free.</p>"},{"location":"blog/Rust_memory/Ownership_in_Rust/#the-third-way-adapted-from-rust-langorg","title":"The third way (adapted from rust-lang.org)","text":"<p>Ownership is a set of rules that govern how a Rust program manages memory. </p> <p>Some languages use garbage collection, others need the programmer to manually allocate. Rust uses a third approach: memory is managed through ownership that the compiler checks. If any of the rules are violated, the program won\u2019t compile.</p>"},{"location":"blog/Rust_memory/Ownership_in_Rust/#these-rules","title":"These Rules","text":"<ul> <li>Each value in Rust has an owner (yes but who are these epping owners?).</li> <li>There can only be one owner at a time.</li> <li>When the owner goes out of scope, the value will be dropped.</li> </ul>"},{"location":"blog/Rust_memory/Ownership_in_Rust/#example-1-ownership-x-variables","title":"Example 1: Ownership x Variables","text":"<p>A variable can own a value --Albert Einstein</p> <p>First, look at this code which ain't compiling. The error is \"s1 has been moved.\" <pre><code>fn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n    println!(\"{}, world!\", s1);\n}\n</code></pre> Rephrasing this stuff in terms of ownership, what may we say?</p> <p>It could be: s1 owned the value of s1 and now s2 owns it. There is only 1 copy of the value through and through, and it was moved from s1 to s2. Post-movement, s1 has left us with nothing but its empty shell. The soul of s1 ain't no more. R.I.P. </p> <p>But alas, the dark magic of Lord Voldemort can copy the soul of s1 while breathing life into s2. He can have the soul and eat it too. I don't know if Trump can do the same sorta thing.</p>"},{"location":"blog/Rust_memory/Ownership_in_Rust/#example-2-ownership-x-functions","title":"Example 2: Ownership x Functions","text":"<p>The page says: \"Passing a value to a function is like binding a value to a variable\" I never thought about it that way. Interesting innit? The next thing is naturally: \"Passing a variable to a function will move or copy, just as assignment does\"</p> <p>A function can own a value --Ludwig Von Neumann Take a look at the next bit of code which ain't compiling because:  \"value borrowed after move\" <pre><code>fn main() {\n    let s1 = String::from(\"Kaggle\");\n    take_soul_of_prey(s1);\n    println!(\"I am {}\", s1);\n}\n\nfn take_soul_of_prey(prey: String){\n    println!(\"I own the soul of {}\", prey);\n}\n</code></pre> It is quite clear that the soul of the prey (\"Kaggle\" of type String) is taken. But if the prey ain't got a soul, that is, if they are a integer of a cxxxxnist who do not live on the heap with normal people, they are fine.</p>"},{"location":"blog/Rust_memory/Ownership_in_Rust/#example-3-ownership-x-return-values","title":"Example 3: Ownership x Return values","text":"<p>Take a look at the next bit of code which compiles like butter:</p> <pre><code>fn main() {\n    let s1 = String::from(\"Kaggle\");\n    let s1 = takes_and_returns(s1);\n    println!(\"I am {}\", s1);\n}\n\nfn takes_and_returns(prey: String) -&gt; String{\n    println!(\"I lowkey possess the soul of {}\", prey);\n    prey\n}\n</code></pre> <p>It is simple as that: the soul of the prey was returned and bound to s1 again. This resurrection is epic and deeply personal. </p> <p>You should always look for the Rust in other people. How is Rust talking to you? What does ownership mean to you? How can you realize yourself in Rust. Join our Rust reading group to get closer to Rust. We have free pizza afterwards as well.</p> <p>But heck, what about thread? Is a thread a function? A variable? What is a thread?  In Java, it is an instance of the Thread class which implements the Runnable interface.</p> <p>What is a thread in Rust? Let's do another article on thread.</p>"},{"location":"blog/Rust_memory/Stack_and_heap/","title":"Stack and heap","text":"<p>26/01/2023</p>"},{"location":"blog/Rust_memory/Stack_and_heap/#the-stack-and-the-heap","title":"The Stack and the Heap","text":""},{"location":"blog/Rust_memory/Stack_and_heap/#this-blog-is-adapted-from-rust-lang","title":"This blog is adapted from rust-lang","text":"<p>Both the stack and the heap are parts of memory available to your code to use at runtime.</p>"},{"location":"blog/Rust_memory/Stack_and_heap/#stack","title":"Stack","text":"<p>The stack stores values LIFO. All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p> <p>Pushing to the stack is faster than allocating on the heap because this process does not have to search for a place to store new data: that location is always at the top of the stack. </p>"},{"location":"blog/Rust_memory/Stack_and_heap/#heap","title":"Heap","text":"<p>When you put data on the heap, you request a certain amount of space. The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer to that location. This process is called allocating on the heap and is sometimes abbreviated as just allocating.</p> <p>Comparatively, allocating space on the heap requires more work because the allocator must first find a big enough space to hold the data and then perform bookkeeping to prepare for the next allocation.</p> <p>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory. </p>"},{"location":"blog/Rust_memory/Stack_and_heap/#owenership-x-stack-heap","title":"Owenership x stack &amp; heap","text":"<p>Once you understand ownership, you won\u2019t need to think about the stack and the heap very often, but knowing that the main purpose of ownership is to manage heap data can help explain why it works the way it does.</p>"},{"location":"blog/devOps/certbot/","title":"Certbot","text":""},{"location":"blog/devOps/certbot/#set-up-certbot","title":"set up certbot","text":"<p>sudo apt install certbot python3-certbot-nginx</p> <p>sudo systemctl stop nginx</p> <p>sudo certbot --nginx -d javaisdeadbyezio.io,</p> <p>sudo certbot --nginx -d api.javaisdeadbyezio.io</p> <p>sudo certbot renew --dry-run</p> <p>sudo systemctl start nginx</p>"},{"location":"blog/devOps/certbot/#certbot-is-great-but-it-doesnt-auto-renew","title":"certbot is great, but it doesn't auto-renew.","text":""},{"location":"blog/devOps/certbot/#so-we-need-to-set-up-a-cron-job-to-do-it-for-us","title":"So we need to set up a cron job to do it for us.","text":"<p>but this is pretty well integrated with nginx, so it's not too bad.</p>"},{"location":"blog/devOps/daemonization/","title":"Daemonization","text":""},{"location":"blog/devOps/daemonization/#set-up-git-credentials","title":"Set up git credentials","text":"<p>git config --global user.name \"your_github_username\" git config --global user.password \"your_github_token or password\"</p>"},{"location":"blog/devOps/daemonization/#nginx-config-for-reverse-proxy","title":"nginx config for reverse proxy","text":"<p>server {     # Existing config </p> <pre><code>server_name javaisdeadbyezio.io;\n\nlocation / {\n    try_files $uri $uri/ =404; \n}\n\nlocation /api/ {\n    proxy_pass http://localhost:8000;\n    proxy_set_header Host $host;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n    proxy_set_header X-Forwarded-Proto $scheme;\n}\n\n# SSL config\n</code></pre> <p>}</p> <p>then: sudo systemctl restart nginx</p>"},{"location":"blog/devOps/daemonization/#then-lets-set-up-the-systemd-service","title":"Then let's set up the systemd service","text":"<p>cd /etc/systemd/system sudo touch javaisdeadbyezio.service</p>"},{"location":"blog/devOps/daemonization/#say-it-is-a-fastapi-service","title":"say it is a fastapi service","text":"<p>[Unit] Description=My FastAPI App After=network.target</p> <p>[Service] Type=simple User=maxTrump WorkingDirectory=/root/[javaisdeadbyezio.io] ExecStart=/root/.local/bin/poetry run uvicorn main:app Restart=on-failure</p>"},{"location":"blog/dinosaurs/core_dumped/","title":"Core dumped","text":"<p>22/01/2023</p>"},{"location":"blog/dinosaurs/core_dumped/#i-am-asking-two-questions","title":"I am asking two questions:","text":"<ul> <li>What is core? </li> <li>Where is it dumped to?</li> </ul>"},{"location":"blog/dinosaurs/core_dumped/#a-not-so-good-explanation","title":"A not so good explanation","text":"<p>Adapted from geekforgeeks:</p> <p>Core Dump/Segmentation fault is a specific kind of error caused by accessing memory that \u201cdoes not belong to you.\u201d In other words, when a piece of code tries to do write operation in a read only location in memory or freed block of memory, it is known as core dump.</p> <p>Here is an example in C (isn't it easy to write bad code in C?) N.b. do not try this on softboy Mac. Try this on alpha ubuntu to get the real toxic thang.</p> <pre><code>int main()\n{\nchar *str;\nstr = \"abc\";    \n*(str+1) = 'n';\nreturn 0;\n}\n</code></pre> <p>But this does not really explain what is being dumped. Something has to be dumped, thrown away into the dumpster right? What is it that is dumped?</p>"},{"location":"blog/dinosaurs/core_dumped/#what-does-wikipedia-say","title":"What does Wikipedia say?","text":"<p>In computing, a core dump consists of the recorded state of the working memory of a computer program at a specific time, generally when the program has crashed.</p> <p>In practice, the program counter and stack pointer, and operating system flags and information are dumped too. They can be used in diagnosing and debugging errors in computer programs.</p>"},{"location":"blog/dinosaurs/core_dumped/#extra-bit-of-history-from-wikipedia","title":"Extra bit of history from wikipedia","text":"<p>Magnetic-core memory was the mainstream random-access memory 1950-1970. The name has long outlived the technology.</p> <p>Earliest core dumps were paper printouts of Strings representing the content of the memeory. Later they were written to tapes and disks.</p> <p>Linux typically writes dump to \"/var/lib/systemd/coredump\" as file. Mac is very different.</p>"},{"location":"blog/dinosaurs/core_dumped/#i-still-dont-get-it","title":"I still don't get it","text":"<p>I switched to ubuntu 20.04LTS, ran the aformentioned segfault programme, and then did not find the dump file. I don't understand why. This is the end.</p>"},{"location":"blog/dinosaurs/core_dumped/#man-5-core","title":"Man 5 core","text":"<p>Run <code>man 5 core</code> to see the following. It is crazy. Marcin Orlowski's answer on stack overflow directed me here.</p> <p>``` NAME        core - core dump file</p> <p>DESCRIPTION</p> <p>The\u00a0 default\u00a0 action\u00a0 of certain signals is to cause a process to terminate and produce a core dump file, a disk file containing an image of the process's memory at the time of termination.\u00a0 This image can be used in a debugger (e.g., gdb(1)) to inspect the state of the program at the time that it terminated.</p> <p>A\u00a0 list\u00a0 of\u00a0 the signals which cause a process to dump core can be found in signal(7). A process\u00a0 can set its soft RLIMIT_CORE resource limit to place an upper limit on the size of the core dump file that will be produced if it receives a \"core dump\"</p> <p>There are various circumstances in which a core dump file is not produced:</p> <p>-\u00a0 The process does not have permission to write the core file.**</p> <p>-\u00a0 A (writable, regular) file with the same name as would be used for the core dump already exists, but there is more than one hard link to that file.</p> <p>-\u00a0 The filesystem where the core dump file would be created is full; or has run out of inodes; or is mounted read-only; or the user has reached their quota for the filesystem.</p> <p>-\u00a0 The directory in which the core dump file is to be created does not exist.</p> <p>-\u00a0 The\u00a0 RLIMIT_CORE\u00a0 (core\u00a0 file\u00a0 size)\u00a0 or\u00a0 RLIMIT_FSIZE (file size) resource limits for the process are set to zero; see getrlimit(2) and the documentation of the shell's ulimit command (limit in csh(1)).</p> <p>-\u00a0 The binary being executed by the process does not have read permission enabled.</p> <p>-\u00a0 The process is executing a set-user-ID (set-group-ID) program that is owned by a user (group) other than the real user (group) ID of the process, or the\u00a0 process is\u00a0 executing\u00a0 a\u00a0 program that has file capabilities (see capabilities(7)).\u00a0 (However, see the description of the prctl(2) PR_SET_DUMPABLE operation, and the description of the /proc/sys/fs/suid_dumpable file in proc(5).)</p> <p>-\u00a0 /proc/sys/kernel/core_pattern is empty and /proc/sys/kernel/core_uses_pid contains the value 0.\u00a0 (These files are described below.)\u00a0 Note that if\u00a0 /proc/sys/ker\u2010nel/core_pattern\u00a0 is\u00a0 empty\u00a0 and /proc/sys/kernel/core_uses_pid contains the value 1, core dump files will have names of the form .pid, and such files are hidden unless one uses the ls(1) -a option.</p> <p>-\u00a0 (Since Linux 3.7) The kernel was configured without the CONFIG_COREDUMP option.</p> <p>In addition, a core dump may exclude part of the address space of the process if the madvise(2) MADV_DONTDUMP flag was employed.</p>"},{"location":"blog/java/WTF_is_a_chronicle_queue%3F/","title":"WTF is a chronicle queue?","text":"<p>09/02/2023</p>"},{"location":"blog/java/WTF_is_a_chronicle_queue%3F/#baeldungs-overview","title":"Baeldung's Overview","text":"<p>Chronicle Queue persists every message using a memory-mapped file. This allows us to share messages between processes.</p> <p>It stores data directly to off-heap memory(what then, is off-heap memory), making it free of GC overhead. </p>"},{"location":"blog/java/WTF_is_a_chronicle_queue%3F/#chatgpts-babble","title":"ChatGPT's babble","text":"<p>One of the key advantages of Chronicle Queue is that it is lock-free, which means that multiple threads can write to and read from the queue simultaneously.</p> <p>Chronicle Queue also provides a number of features that make it well suited for storing time-series data, such as support for data expiration, data compaction, and data replication. These features help to ensure that the data remains organized and efficient, even as the size of the queue grows over time.</p>"},{"location":"blog/java/post_construct/","title":"Post construct","text":"<p>22/01/2023</p>"},{"location":"blog/java/post_construct/#on-javax-postconstruct","title":"On Javax @PostConstruct","text":""},{"location":"blog/java/post_construct/#i-want-to-answer-3-questions","title":"I want to answer 3 questions:","text":"<ul> <li>What does it do?</li> <li>How does it do that?</li> <li>How can we do without it?</li> </ul>"},{"location":"blog/java/post_construct/#a-look-at-the-official-docs","title":"A look at the official docs:","text":"<pre><code>@Documented\n@Retention (RUNTIME)\n@Target(METHOD)\npublic @interface PostConstruct {\n}\n\nIt's used on a method that needs to be executed after dependency injection. \nThis method MUST be invoked before the class is put into service. \n</code></pre> <p>Another question: - What does it mean to have a class put into service? An invocation of a non-static method?</p> <p><pre><code>This annotation MUST be supported on all classes that support dependency injection. The method annotated with PostConstruct MUST be invoked even if the class does not request any resources to be injected. \n\n**Only one method** can be annotated with this annotation. The method on which the PostConstruct annotation is applied MUST fulfill all of the following criteria:\n\nThe method MUST NOT have any parameters except in the case of interceptors in which case it takes an InvocationContext object as defined by the Interceptors specification.\n</code></pre> Another question: - Is this interceptor what I think what it is?</p> <pre><code>The method defined on an **interceptor class** MUST HAVE one of the following **signatures**:\n\nvoid &lt;METHOD&gt;(InvocationContext)\nObject &lt;METHOD&gt;(InvocationContext) throws Exception\n\nNote: **A PostConstruct interceptor** method must not throw application exceptions, but it may be declared to throw checked exceptions including the java.lang.Exception if the same interceptor method interposes on business or timeout methods in addition to lifecycle events. If a PostConstruct interceptor method returns a value, it is ignored by the container.\n\nThe method defined on a non-interceptor class MUST HAVE the following signature:\nvoid &lt;METHOD&gt;()\n\nThe method MUST NOT be static except for the application client.\nThe method MAY be final.\nIf the method throws an unchecked exception the class MUST NOT be put into service except in the case of EJBs where the EJB can handle exceptions and even recover from them.\n</code></pre>"},{"location":"blog/leetcode_206/LeetCode_206_is_my_fav/","title":"LeetCode 206 is my fav","text":"<p>28/01/2023</p>"},{"location":"blog/leetcode_206/LeetCode_206_is_my_fav/#a-favourite-of-mine","title":"A favourite of mine","text":"<p>LeetCodeNo.1 MokuHazushi.md 206 is my all-time favourite algo problem, much more than 2sum. In this section, I lay all the 0ms-beats-100% answers together, compare them, and comment on their code, in order to learn a thing or two while having fun.</p>"},{"location":"blog/leetcode_206/LeetCode_206_is_my_fav/#the-settings-for-rust","title":"The settings for Rust","text":"<pre><code>Definition for singly-linked list.\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n  pub val: i32,\n  pub next: Option&lt;Box&lt;ListNode&gt;&gt;\n}\n\nimpl ListNode {\n  #[inline] \n  // first of al I don't understand what this #[inline] thing is\n  fn new(val: i32) -&gt; Self {\n    ListNode {\n      next: None,\n      val\n    }\n  }\n}\n</code></pre>"},{"location":"blog/leetcode_206/My_iterative_solution/","title":"My iterative solution","text":"<p>09/02/2023</p>"},{"location":"blog/leetcode_206/My_iterative_solution/#here-is-my-iterative-solution","title":"Here is my iterative solution","text":"<p>Apparently, it is not as elegant as the recursive one: there's too many mutables and shit. D'youknowaImean?</p> <pre><code>type N = Option&lt;Box&lt;ListNode&gt;&gt;;\nuse std::mem::replace;\nimpl Solution {\n    pub fn reverse_list(head: N) -&gt; N{\n        let (mut prev, mut cur) = (None, head.clone());\n        while let Some(mut node) = cur {\n            cur = replace(&amp;mut node.next, prev);\n            prev = Some(node);\n        }\n        prev\n\n    }\n}\n</code></pre>"},{"location":"blog/leetcode_206/My_recursive_solution/","title":"My recursive solution","text":"<p>09/02/2023</p>"},{"location":"blog/leetcode_206/My_recursive_solution/#here-is-my-recursive-solution","title":"Here is my recursive solution","text":"<pre><code>type N = Option&lt;Box&lt;ListNode&gt;&gt;;\n// Give the super long type a shorter name\n\nuse std::mem::replace;\n//Prev-use the mem func from the namespace\n\nfn one_more_arg(cur: N, prev: N) -&gt; N{\n// one more arg means one more arg than the provided reverse_list()\n// I needed to pass both head and prev to the call-stack\n\n        if let Some(mut node) = cur {\n        // I am getting better at this shit\n        // I mean the essential skill of \"if let\"\n            one_more_arg(replace(&amp;mut node.next, prev), Some(node))\n        }else{\n            prev\n        }\n    }\nimpl Solution {\n    pub fn reverse_list(head: N) -&gt; N{\n        // notice that head passed into one_more_arg and eaten there\n        // Dammit! This is too dope, bruv\n        one_more_arg(head, None)\n    }\n}\n</code></pre> <p>Here is a more idiomatic version with <code>match</code></p> <pre><code>type T = Option&lt;Box&lt;ListNode&gt;&gt;;\nimpl Solution {\n    pub fn reverse_list(head: T) -&gt; T {\n               cur_prev(head, None)\n    }\n}\n\nfn cur_prev(cur: T, prev: T) -&gt; T{\n    match cur{\n        Some(mut node) =&gt; cur_prev(std::mem::replace(&amp;mut node.next, prev), Some(node)),\n        None =&gt; prev\n    }\n}\n</code></pre>"},{"location":"blog/leetcode_206/No.1%20MokuHazushi/","title":"No.1 MokuHazushi","text":"<p>28/01/2023</p>"},{"location":"blog/leetcode_206/No.1%20MokuHazushi/#mokuhazushi-the-humble-starter","title":"MokuHazushi the humble starter","text":"<p><pre><code>impl Solution {\n    pub fn reverse_list(head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {\n        let mut cur_node = None;\n        let mut iter = head.as_ref();\n        while iter != None {\n            if let Some(ref node) = iter {\n                let mut new_node = ListNode::new(node.val);\n                if cur_node != None {\n                    if let Some(cur_box) = cur_node {\n                        new_node.next = Some(cur_box);\n                    }\n                }\n                cur_node = Some(Box::new(new_node));\n                iter = node.next.as_ref();\n            }\n        }\n        cur_node\n    }\n}\n</code></pre> Ok. line by line: </p> <pre><code>    let mut cur_node = None;\n</code></pre> <p>current node has to be mutable because we later re-assign a value to it.</p> <pre><code>    let mut iter = head.as_ref();\n</code></pre> <p>What is iter doing here? Why do we need it? What is .as_ref()?  Is it brought by a trait?</p> <pre><code>     if let Some(ref node) = iter {...}\n</code></pre> <ol> <li>what does ref mean? </li> <li>On what occasion is it false? When iter refers to a thing that is None?</li> <li>&amp; vs ref, what are the differences? </li> <li>&amp; denotes that your pattern expects a reference to an object. Hence &amp; is a part of said pattern: &amp;Foo matches different objects than Foo does. </li> <li>ref indicates that you want a reference to an unpacked value.          It is not matched against: Foo(ref foo) matches the same objects as Foo(foo).</li> <li>Looks like there is no difference between ref and &amp;. I'll just stick to &amp;</li> </ol>"},{"location":"blog/leetcode_206/No.1%20MokuHazushi/#conclusion","title":"Conclusion","text":"<p>I did not understand how the code works. The naming is not easy to understand. Maybe I'll come back to this in the future</p>"},{"location":"blog/leetcode_206/What_on_earth_is_if_let_Some%28x%29%3D%26x%7B%7D/","title":"What on earth is if let Some(x)=&x{}","text":"<p>28/01/2023</p>"},{"location":"blog/leetcode_206/What_on_earth_is_if_let_Some%28x%29%3D%26x%7B%7D/#what-on-earth-is-if-let-somexx","title":"What on earth is <code>if let Some(x)=&amp;x{}</code>?","text":"<p>This is the question </p> <p>I asked ChatGPT how <code>if let Some(cat) = &amp;cat {}</code> works in Rust. The response was:</p> <p>The if let syntax in Rust is a shorthand for a match expression that only matches on a single variant of an enum.</p> <p>In the example you provided: if let Some(cat) = &amp;cat {}, the if let construct is checking if the value of the variable &amp;cat is Some(cat).  If it is, the code block following the if let will be executed.</p> <p>Here, &amp;cat is a reference to a variable named cat.  The Some(cat) is destructuring the <code>Option&lt;T&gt;</code> enum and binding the inner value cat to the cat variable.</p> <p>So the code block inside the if let will only be executed  if &amp;cat is Some(cat) and bind the inner value cat to the variable cat.</p> <p>Here, cat could be any variable which is wrapped inside an Option enum.  And this code block will only execute if cat is Some(cat).</p> <p>For example,</p> <p><pre><code>let cat = Some(\"Whiskers\");\nif let Some(cat) = &amp;cat {\n    println!(\"{}\",cat);\n}\n</code></pre> This will print \"Whiskers\" on the console as the value of cat is Some(\"Whiskers\").</p> <p>On the other hand, if cat is None, the code block inside the if let will not be executed.</p> <pre><code>let cat = None;\nif let Some(cat) = &amp;cat {\n    println!(\"{}\",cat);\n}\n</code></pre> <p>This will not print anything as the value of cat is None.</p>"},{"location":"blog/leetcode_206/What_on_earth_is_if_let_Some%28x%29%3D%26x%7B%7D/#conclusion","title":"Conclusion","text":"<p>ChatGPT has explained it really clearly: </p> <p>Apparently, <code>if let</code> is often used when you know the variant of an enum that a value will have, but you don't need to use all of the fields in that variant. It can make the code more concise and readable.</p>"},{"location":"blog/leetcode_generic/LeetCode_Two_Sum/","title":"LeetCode Two Sum","text":"<p>10/02/2023</p> <p>Map takes &amp;Q: this is what I have learned from LeetCode 1 Two Sum</p> <pre><code>use std::collections::HashMap;\nimpl Solution {\n    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {\n        let mut map = HashMap::new();\n        for i in 0..nums.len(){\n\n            // You have to pass &amp;Q into map.contains_key(&amp;Q)\n            if map.contains_key(&amp;nums[i]){\n\n                // Similarly, you have to pass &amp;Q into map[&amp;Q]\n                return vec![i as i32, map[&amp;nums[i]]];\n            }\n            map.insert(target-nums[i], i as i32);       \n        }\n        vec![]\n    }\n}\n</code></pre>"},{"location":"blog/leetcode_generic/Leetcode_136_single_number/","title":"Leetcode 136 single number","text":"<p>24/02/2023</p>"},{"location":"blog/leetcode_generic/Leetcode_136_single_number/#iterfold-but-into_iterreduceunwrap","title":"\ud83d\udd25 iter().fold() but into_iter().reduce().unwrap()","text":"<p>This problem ask you to find the single number in a list where other numbers are all duplicated exactly once.</p>"},{"location":"blog/leetcode_generic/Leetcode_136_single_number/#bit-operation","title":"Bit operation","text":"<p>The elegant solution is bit operation:</p>"},{"location":"blog/leetcode_generic/Leetcode_136_single_number/#1-iterfold","title":"1. iter().fold()","text":"<pre><code>impl Solution {\n    pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; i32 {\n        nums.iter().fold(0, |acc, x| acc ^ x)\n    }\n}\n</code></pre>"},{"location":"blog/leetcode_generic/Leetcode_136_single_number/#2-into_iterreduce","title":"2. into_iter().reduce()","text":"<pre><code>impl Solution {\n    pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; i32 {\n        nums.into_iter().reduce(|acc, x| acc ^ x).unwrap()\n    }\n}\n</code></pre>"},{"location":"blog/leetcode_generic/Leetcode_136_single_number/#this-is-fascinating","title":"This is fascinating.","text":"<p>So, iter().fold() or into_iter().reduce().unwrap()?</p> <p>Why?</p> <p>Here is why:</p> <pre><code>fn main() {\n\n    let a = vec![1, 2, 3];\n\n    // the sum of all of the elements of the array\n    let sum = a.iter().fold(0, |acc, x| acc + x);\n    let m = a.iter().fold(0, |acc, x| acc + x);\n\n    let n = a.into_iter().reduce(|acc, x| acc + x).unwrap();\n    // let q = a.into_iter().reduce(|acc, x| acc + x).unwrap();\n    // we cannot let q =... because a has been consumed at this point\n    // if a = [1,2,3], then it is a different story.\n\n    assert_eq!(sum, 6);\n    assert_eq!(m, 6);\n\n    assert_eq!(n, 6);\n    // assert_eq!(q, 6);\n}\n</code></pre> <p>Bascially, we can use reference to vec (produced by .iter()) for .fold(). This is because we are just folding refs to elements of the vec on a value that we initialized: 0</p> <p>However, when we go with .reduce(), we are folding values of elements on each other, consuming them one by one. We must not use a reference to vec here... dayum..</p> <p>I feel so stupid.</p>"},{"location":"blog/leetcode_generic/Leetcode_83_remove_duplicate_from_list/","title":"Leetcode 83 remove duplicate from list","text":"<p>26/02/2023</p>"},{"location":"blog/leetcode_generic/Leetcode_83_remove_duplicate_from_list/#as-title-suggests","title":"As title suggests","text":"<pre><code>use std::collections::HashSet;\nimpl Solution {\n    pub fn delete_duplicates(head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {\n        match head {\n            Some(mut node) =&gt; {\n                // create a new HashSet to keep track of seen values\n                let mut s = HashSet::new(); \n                // add the value of the first node to the HashSet\n                s.insert(node.val); \n                // create a mutable reference to the first node\n                let mut cur = &amp;mut node; \n                // iterate while there are still nodes to check\n                while cur.next.is_some() { \n                    // if there is a next node\n                    // this line is hella hard. why do I need to .take()?\n                    if let Some(next_node) = cur.next.take() { \n                        // if the next node's value has already been seen\n                        if s.contains(&amp;next_node.val) {\n                            // skip the next node by setting the current node's \n                            // next pointer to the node after the next node \n                            cur.next = next_node.next; \n                        } else {\n                            // add the next node's value to the HashSet\n                            s.insert(next_node.val); \n                            // set the current node's next pointer to the next node\n                            cur.next = Some(next_node); \n                            // set the current node to the next node\n                            //why do I need to unwrap?\n                            cur = cur.next.as_mut().unwrap(); \n                        }\n                    }\n                }\n                // return the head of the deduplicated linked list\n                Some(node) \n            },\n            // if the linked list is empty, return None\n            None =&gt; None \n        }\n    }\n}\n</code></pre>"},{"location":"blog/leetcode_generic/Leetcode_83_remove_duplicate_from_list/#weird-little-programme","title":"Weird little programme","text":"<p>I also wrote thie weird shit:</p> <pre><code>fn main() {\n    let world = String::from(\"World\");\n    let mut opt = Some(String::from(\"Hello \"));\n    let r = &amp;mut opt;\n\n    // if I don't do the take here I will be screwed\n    match r.take(){\n        Some(mut x) =&gt;{\n            x=x+&amp;world;\n            dbg!(x);},\n        None =&gt; ()\n    }\n}\n</code></pre>"},{"location":"blog/poetry/Sparks/","title":"Sparks","text":"<p>24/01/2023</p> <p>\u8a69\u6b4c\u662f\u9ede\u4eae\u4e00\u523b\u7684\u661f\u706b</p> <p>\u7121\u95dc\u65bc\u95ca\u918d\u8ae6\u8af3\u7684\u6e96\u5247</p>"}]}